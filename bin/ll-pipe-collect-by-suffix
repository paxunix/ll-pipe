#!/usr/bin/env zsh

# Read list of filenames on stdin, append the given suffix to each, the
# append the contents of each resulting file to the given filename, then remove
# each resulting filename.
#
# Options:
# --suffix suf
#   Appends suf to each filename read from stdin and if the resulting
#   filename is readable, write its contents to the given file.
# --successful-only
#   Only write and delete any files if their command executed successfully.
# --output-file file
#   Appends contents to file.

. ${ll_pipe_dir}/../etc/ll-pipe-fns || return 1

enableDebug && setopt xtrace


local -A opts
zparseopts -D -A opts -- \
    "-successful-only" \
    "-suffix:" \
    "-output-file:" \

findTool cat || return 1
findTool rm || return 1

local file
local chunkStatus
while read -r file
do
    # If only collecting successful chunks, skip this chunk if its exit
    # status was not 0.  If there was any problem with the contents of the
    # .done file, default the status to 1, since that implies there was a
    # problem with that chunk.
    if (( ${+opts[--successful-only]} ))
    then
        if (( ${chunkStatus:=$(< ${file}.done)} != 0 ))
        then
            verbose "Not collecting ${file}${opts[--suffix]}, exit status=${chunkStatus}"
            continue
        fi
    fi

    file=${file}${opts[--suffix]}

    verbose "Collecting ${file}"

    ${=TOOL_CAT} ${file} >> ${opts[--output-file]}
    ${=TOOL_RM} -f ${file}
done

# vim: ft=zsh
