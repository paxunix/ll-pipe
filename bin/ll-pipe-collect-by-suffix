#!/usr/bin/env zsh

# Read list of filenames on stdin, append the given suffix to each, the
# append the contents of each resulting file to the given filename, then remove
# each resulting filename.
#
# Options:
# --suffix suf
#   Appends suf to each filename read from stdin and if the resulting
#   filename is readable, write its contents to the given file.
# --successful-only
#   Only write and delete any files if their command executed successfully.
# --output-file file
#   Appends contents to file.

enableDebug && setopt xtrace

local -A opts
zparseopts -D -A opts -- \
    "-successful-only" \
    "-suffix:" \
    "-output-file:" \

findTool cat || return 1
findTool rm || return 1

local file
while read -r file
do
    # If only collecting succesful chunks, skip this chunk if its exit
    # status was not 0.  If there was any problem with the contents of the
    # .done file, default the status to 1, since that implies there was a
    # problem with that chunk.
    (( ${+opts[--successful-only]} &&
       ${(zf)"$(< ${file}.done)":-1} != 0 )) && continue

    if [[ -r ${file}${opts[--suffix]} ]]
    then
        ${=TOOL_CAT} ${file}${opts[--suffix]} >> ${opts[--output-file]}
        ${=TOOL_RM} -f ${file}${opts[--suffix]}
    fi

    # XXX:  should the script return false if a file was passed in but could
    # not be read?
done

# vim: ft=zsh
